// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"os"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/MartinSimango/daggerverse/gopkg/internal/dagger"
	"github.com/MartinSimango/daggerverse/gopkg/internal/querybuilder"
	"github.com/MartinSimango/daggerverse/gopkg/internal/telemetry"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Gopkg) MarshalJSON() ([]byte, error) {
	var concrete struct {
		GpgConfig *GitGpgConfig
	}
	concrete.GpgConfig = r.GpgConfig
	return json.Marshal(&concrete)
}

func (r *Gopkg) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		GpgConfig *GitGpgConfig
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.GpgConfig = concrete.GpgConfig
	return nil
}

func (r GitGpgConfig) MarshalJSON() ([]byte, error) {
	var concrete struct {
		GpgKey         *dagger.Secret
		GpgKeyId       *dagger.Secret
		GpgPassword    *dagger.Secret
		GitAuthorName  string
		GitAuthorEmail string
	}
	concrete.GpgKey = r.GpgKey
	concrete.GpgKeyId = r.GpgKeyId
	concrete.GpgPassword = r.GpgPassword
	concrete.GitAuthorName = r.GitAuthorName
	concrete.GitAuthorEmail = r.GitAuthorEmail
	return json.Marshal(&concrete)
}

func (r *GitGpgConfig) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		GpgKey         *dagger.Secret
		GpgKeyId       *dagger.Secret
		GpgPassword    *dagger.Secret
		GitAuthorName  string
		GitAuthorEmail string
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.GpgKey = concrete.GpgKey
	r.GpgKeyId = concrete.GpgKeyId
	r.GpgPassword = concrete.GpgPassword
	r.GitAuthorName = concrete.GitAuthorName
	r.GitAuthorEmail = concrete.GitAuthorEmail
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		os.Exit(2)
	}
}

func unwrapError(rerr error) string {
	var gqlErr *gqlerror.Error
	if errors.As(rerr, &gqlErr) {
		return gqlErr.Message
	}
	return rerr.Error()
}

func dispatch(ctx context.Context) (rerr error) {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	defer func() {
		if rerr != nil {
			if err := fnCall.ReturnError(ctx, dag.Error(unwrapError(rerr))); err != nil {
				fmt.Println("failed to return error:", err)
			}
		}
	}()

	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		var exec *dagger.ExecError
		if errors.As(err, &exec) {
			return exec.Unwrap()
		}
		return err
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}

	if err := fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Gopkg":
		switch fnName {
		case "Test":
			var parent Gopkg
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var source *dagger.Directory
			if inputArgs["source"] != nil {
				err = json.Unmarshal([]byte(inputArgs["source"]), &source)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg source", err))
				}
			}
			return (*Gopkg).Test(&parent, ctx, source)
		case "Release":
			var parent Gopkg
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var source *dagger.Directory
			if inputArgs["source"] != nil {
				err = json.Unmarshal([]byte(inputArgs["source"]), &source)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg source", err))
				}
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			var dryRun bool
			if inputArgs["dryRun"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dryRun"]), &dryRun)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dryRun", err))
				}
			}
			return (*Gopkg).Release(&parent, ctx, source, token, dryRun)
		case "GopkgFlow":
			var parent Gopkg
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var source *dagger.Directory
			if inputArgs["source"] != nil {
				err = json.Unmarshal([]byte(inputArgs["source"]), &source)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg source", err))
				}
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			var dryRun bool
			if inputArgs["dryRun"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dryRun"]), &dryRun)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dryRun", err))
				}
			}
			return (*Gopkg).GopkgFlow(&parent, ctx, source, token, dryRun)
		case "WithGitGpgConfig":
			var parent Gopkg
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var gpgKey *dagger.Secret
			if inputArgs["gpgKey"] != nil {
				err = json.Unmarshal([]byte(inputArgs["gpgKey"]), &gpgKey)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg gpgKey", err))
				}
			}
			var gpgKeyId *dagger.Secret
			if inputArgs["gpgKeyId"] != nil {
				err = json.Unmarshal([]byte(inputArgs["gpgKeyId"]), &gpgKeyId)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg gpgKeyId", err))
				}
			}
			var gpgPassword *dagger.Secret
			if inputArgs["gpgPassword"] != nil {
				err = json.Unmarshal([]byte(inputArgs["gpgPassword"]), &gpgPassword)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg gpgPassword", err))
				}
			}
			var gitAuthorName string
			if inputArgs["gitAuthorName"] != nil {
				err = json.Unmarshal([]byte(inputArgs["gitAuthorName"]), &gitAuthorName)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg gitAuthorName", err))
				}
			}
			var gitAuthorEmail string
			if inputArgs["gitAuthorEmail"] != nil {
				err = json.Unmarshal([]byte(inputArgs["gitAuthorEmail"]), &gitAuthorEmail)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg gitAuthorEmail", err))
				}
			}
			return (*Gopkg).WithGitGpgConfig(&parent, gpgKey, gpgKeyId, gpgPassword, gitAuthorName, gitAuthorEmail), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithDescription("A generated module for Gopkg functions\n\nThis module has been generated via dagger init and serves as a reference to\nbasic module structure as you get started with Dagger.\n\nTwo functions have been pre-created. You can modify, delete, or add to them,\nas needed. They demonstrate usage of arguments and return types using simple\necho and grep commands. The functions can be called from the dagger CLI or\nfrom one of the SDKs.\n\nThe first line in this comment block is a short description line and the\nrest is a long description with more detail on the module's purpose or usage,\nif appropriate. All modules should have a short description.\n").
			WithObject(
				dag.TypeDef().WithObject("Gopkg", dagger.TypeDefWithObjectOpts{SourceMap: dag.SourceMap("main.go", 31, 6)}).
					WithFunction(
						dag.Function("Test",
							dag.TypeDef().WithKind(dagger.TypeDefKindStringKind)).
							WithDescription("Test the project").
							WithSourceMap(dag.SourceMap("main.go", 36, 1)).
							WithArg("source", dag.TypeDef().WithObject("Directory").WithOptional(true), dagger.FunctionWithArgOpts{Description: "Source directory for the project", SourceMap: dag.SourceMap("main.go", 39, 2), DefaultPath: "."})).
					WithFunction(
						dag.Function("Release",
							dag.TypeDef().WithKind(dagger.TypeDefKindStringKind)).
							WithDescription("Release a new version of the project using semantic-release").
							WithSourceMap(dag.SourceMap("main.go", 45, 1)).
							WithArg("source", dag.TypeDef().WithObject("Directory").WithOptional(true), dagger.FunctionWithArgOpts{Description: "Source directory for the project", SourceMap: dag.SourceMap("main.go", 49, 2), DefaultPath: "."}).
							WithArg("token", dag.TypeDef().WithObject("Secret"), dagger.FunctionWithArgOpts{Description: "GitHub token for the release", SourceMap: dag.SourceMap("main.go", 51, 2)}).
							WithArg("dryRun", dag.TypeDef().WithKind(dagger.TypeDefKindBooleanKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "Dry run the release", SourceMap: dag.SourceMap("main.go", 55, 2), DefaultValue: dagger.JSON("true")})).
					WithFunction(
						dag.Function("GopkgFlow",
							dag.TypeDef().WithKind(dagger.TypeDefKindStringKind)).
							WithDescription("GopkgFlow runs a release flow for a Go project using semantic-release\nThis runs the following steps:\n1. Test the project\n2. Release a new version of the project using semantic-release").
							WithSourceMap(dag.SourceMap("main.go", 66, 1)).
							WithArg("source", dag.TypeDef().WithObject("Directory").WithOptional(true), dagger.FunctionWithArgOpts{Description: "Source directory for the project", SourceMap: dag.SourceMap("main.go", 70, 2), DefaultPath: "."}).
							WithArg("token", dag.TypeDef().WithObject("Secret"), dagger.FunctionWithArgOpts{Description: "GitHub token for the release", SourceMap: dag.SourceMap("main.go", 72, 2)}).
							WithArg("dryRun", dag.TypeDef().WithKind(dagger.TypeDefKindBooleanKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "Dry run the release", SourceMap: dag.SourceMap("main.go", 76, 2), DefaultValue: dagger.JSON("true")})).
					WithFunction(
						dag.Function("WithGitGpgConfig",
							dag.TypeDef().WithObject("Gopkg")).
							WithDescription("WithGitGpgConfig sets the GPG configuration for the git repository. To be used with Release.").
							WithSourceMap(dag.SourceMap("main.go", 86, 1)).
							WithArg("gpgKey", dag.TypeDef().WithObject("Secret"), dagger.FunctionWithArgOpts{Description: "GPG private key for signing the semantic-release bot", SourceMap: dag.SourceMap("main.go", 88, 2)}).
							WithArg("gpgKeyId", dag.TypeDef().WithObject("Secret"), dagger.FunctionWithArgOpts{Description: "GPG key ID", SourceMap: dag.SourceMap("main.go", 90, 2)}).
							WithArg("gpgPassword", dag.TypeDef().WithObject("Secret").WithOptional(true), dagger.FunctionWithArgOpts{Description: "GPG password for the private key, if any", SourceMap: dag.SourceMap("main.go", 93, 2)}).
							WithArg("gitAuthorName", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{Description: "Git author name for the release commits", SourceMap: dag.SourceMap("main.go", 95, 2)}).
							WithArg("gitAuthorEmail", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.FunctionWithArgOpts{Description: "Git author email for the release commits", SourceMap: dag.SourceMap("main.go", 97, 2)})).
					WithField("GpgConfig", dag.TypeDef().WithObject("GitGpgConfig"), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 32, 2)})).
			WithObject(
				dag.TypeDef().WithObject("GitGpgConfig", dagger.TypeDefWithObjectOpts{SourceMap: dag.SourceMap("main.go", 23, 6)}).
					WithField("GpgKey", dag.TypeDef().WithObject("Secret"), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 24, 2)}).
					WithField("GpgKeyId", dag.TypeDef().WithObject("Secret"), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 25, 2)}).
					WithField("GpgPassword", dag.TypeDef().WithObject("Secret"), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 26, 2)}).
					WithField("GitAuthorName", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 27, 2)}).
					WithField("GitAuthorEmail", dag.TypeDef().WithKind(dagger.TypeDefKindStringKind), dagger.TypeDefWithFieldOpts{SourceMap: dag.SourceMap("main.go", 28, 2)})), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
